// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/open_source/v1/open_source.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on RepoInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepoInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepoInfoMultiError, or nil
// if none found.
func (m *RepoInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for FullName

	// no validation rules for Image

	// no validation rules for OwnerId

	// no validation rules for OwnerName

	// no validation rules for Private

	// no validation rules for Desc

	// no validation rules for HtmlUrl

	// no validation rules for Homepage

	// no validation rules for CloneUrl

	// no validation rules for StargazersCount

	// no validation rules for WatchersCount

	// no validation rules for Language

	// no validation rules for LanguageId

	// no validation rules for ForksCount

	// no validation rules for OpenIssuesCount

	// no validation rules for OpenIssues

	// no validation rules for Watchers

	// no validation rules for DefaultBranch

	// no validation rules for Score

	// no validation rules for Size

	// no validation rules for Forks

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return RepoInfoMultiError(errors)
	}

	return nil
}

// RepoInfoMultiError is an error wrapping multiple validation errors returned
// by RepoInfo.ValidateAll() if the designated constraints aren't met.
type RepoInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoInfoMultiError) AllErrors() []error { return m }

// RepoInfoValidationError is the validation error returned by
// RepoInfo.Validate if the designated constraints aren't met.
type RepoInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoInfoValidationError) ErrorName() string { return "RepoInfoValidationError" }

// Error satisfies the builtin error interface
func (e RepoInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoInfoValidationError{}

// Validate checks the field values on QueryFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryFilterMultiError, or
// nil if none found.
func (m *QueryFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetValue

	// no validation rules for Op

	// no validation rules for Field

	if len(errors) > 0 {
		return QueryFilterMultiError(errors)
	}

	return nil
}

// QueryFilterMultiError is an error wrapping multiple validation errors
// returned by QueryFilter.ValidateAll() if the designated constraints aren't met.
type QueryFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryFilterMultiError) AllErrors() []error { return m }

// QueryFilterValidationError is the validation error returned by
// QueryFilter.Validate if the designated constraints aren't met.
type QueryFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryFilterValidationError) ErrorName() string { return "QueryFilterValidationError" }

// Error satisfies the builtin error interface
func (e QueryFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryFilterValidationError{}

// Validate checks the field values on SortOrder with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SortOrder) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SortOrder with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SortOrderMultiError, or nil
// if none found.
func (m *SortOrder) ValidateAll() error {
	return m.validate(true)
}

func (m *SortOrder) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Order

	// no validation rules for Field

	if len(errors) > 0 {
		return SortOrderMultiError(errors)
	}

	return nil
}

// SortOrderMultiError is an error wrapping multiple validation errors returned
// by SortOrder.ValidateAll() if the designated constraints aren't met.
type SortOrderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SortOrderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SortOrderMultiError) AllErrors() []error { return m }

// SortOrderValidationError is the validation error returned by
// SortOrder.Validate if the designated constraints aren't met.
type SortOrderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SortOrderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SortOrderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SortOrderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SortOrderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SortOrderValidationError) ErrorName() string { return "SortOrderValidationError" }

// Error satisfies the builtin error interface
func (e SortOrderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSortOrder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SortOrderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SortOrderValidationError{}

// Validate checks the field values on RepoRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepoRequestMultiError, or
// nil if none found.
func (m *RepoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepoRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepoRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepoRequestValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	// no validation rules for Desc

	// no validation rules for LanguageId

	// no validation rules for OwnerId

	// no validation rules for ID

	for idx, item := range m.GetFilters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RepoRequestValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RepoRequestValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RepoRequestValidationError{
					field:  fmt.Sprintf("Filters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepoRequestValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepoRequestValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepoRequestValidationError{
				field:  "Sort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RepoRequestMultiError(errors)
	}

	return nil
}

// RepoRequestMultiError is an error wrapping multiple validation errors
// returned by RepoRequest.ValidateAll() if the designated constraints aren't met.
type RepoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoRequestMultiError) AllErrors() []error { return m }

// RepoRequestValidationError is the validation error returned by
// RepoRequest.Validate if the designated constraints aren't met.
type RepoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoRequestValidationError) ErrorName() string { return "RepoRequestValidationError" }

// Error satisfies the builtin error interface
func (e RepoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoRequestValidationError{}

// Validate checks the field values on RepoReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepoReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepoReplyMultiError, or nil
// if none found.
func (m *RepoReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepoReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepoReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepoReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return RepoReplyMultiError(errors)
	}

	return nil
}

// RepoReplyMultiError is an error wrapping multiple validation errors returned
// by RepoReply.ValidateAll() if the designated constraints aren't met.
type RepoReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoReplyMultiError) AllErrors() []error { return m }

// RepoReplyValidationError is the validation error returned by
// RepoReply.Validate if the designated constraints aren't met.
type RepoReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoReplyValidationError) ErrorName() string { return "RepoReplyValidationError" }

// Error satisfies the builtin error interface
func (e RepoReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoReplyValidationError{}

// Validate checks the field values on OwnerInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OwnerInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OwnerInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OwnerInfoMultiError, or nil
// if none found.
func (m *OwnerInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *OwnerInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AvatarUrl

	// no validation rules for Type

	// no validation rules for Login

	// no validation rules for HtmlUrl

	// no validation rules for Name

	// no validation rules for Email

	// no validation rules for Bio

	// no validation rules for PublicRepos

	// no validation rules for PublicGists

	// no validation rules for Followers

	// no validation rules for Following

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return OwnerInfoMultiError(errors)
	}

	return nil
}

// OwnerInfoMultiError is an error wrapping multiple validation errors returned
// by OwnerInfo.ValidateAll() if the designated constraints aren't met.
type OwnerInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OwnerInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OwnerInfoMultiError) AllErrors() []error { return m }

// OwnerInfoValidationError is the validation error returned by
// OwnerInfo.Validate if the designated constraints aren't met.
type OwnerInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OwnerInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OwnerInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OwnerInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OwnerInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OwnerInfoValidationError) ErrorName() string { return "OwnerInfoValidationError" }

// Error satisfies the builtin error interface
func (e OwnerInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOwnerInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OwnerInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OwnerInfoValidationError{}

// Validate checks the field values on OwnerRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OwnerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OwnerRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OwnerRequestMultiError, or
// nil if none found.
func (m *OwnerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OwnerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OwnerRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OwnerRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OwnerRequestValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for Email

	if len(errors) > 0 {
		return OwnerRequestMultiError(errors)
	}

	return nil
}

// OwnerRequestMultiError is an error wrapping multiple validation errors
// returned by OwnerRequest.ValidateAll() if the designated constraints aren't met.
type OwnerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OwnerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OwnerRequestMultiError) AllErrors() []error { return m }

// OwnerRequestValidationError is the validation error returned by
// OwnerRequest.Validate if the designated constraints aren't met.
type OwnerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OwnerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OwnerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OwnerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OwnerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OwnerRequestValidationError) ErrorName() string { return "OwnerRequestValidationError" }

// Error satisfies the builtin error interface
func (e OwnerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOwnerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OwnerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OwnerRequestValidationError{}

// Validate checks the field values on OwnerReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OwnerReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OwnerReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OwnerReplyMultiError, or
// nil if none found.
func (m *OwnerReply) ValidateAll() error {
	return m.validate(true)
}

func (m *OwnerReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OwnerReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OwnerReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OwnerReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return OwnerReplyMultiError(errors)
	}

	return nil
}

// OwnerReplyMultiError is an error wrapping multiple validation errors
// returned by OwnerReply.ValidateAll() if the designated constraints aren't met.
type OwnerReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OwnerReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OwnerReplyMultiError) AllErrors() []error { return m }

// OwnerReplyValidationError is the validation error returned by
// OwnerReply.Validate if the designated constraints aren't met.
type OwnerReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OwnerReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OwnerReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OwnerReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OwnerReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OwnerReplyValidationError) ErrorName() string { return "OwnerReplyValidationError" }

// Error satisfies the builtin error interface
func (e OwnerReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOwnerReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OwnerReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OwnerReplyValidationError{}

// Validate checks the field values on LanguageInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LanguageInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LanguageInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LanguageInfoMultiError, or
// nil if none found.
func (m *LanguageInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *LanguageInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for ImageUrl

	// no validation rules for RepoUrl

	// no validation rules for Bio

	if len(errors) > 0 {
		return LanguageInfoMultiError(errors)
	}

	return nil
}

// LanguageInfoMultiError is an error wrapping multiple validation errors
// returned by LanguageInfo.ValidateAll() if the designated constraints aren't met.
type LanguageInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LanguageInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LanguageInfoMultiError) AllErrors() []error { return m }

// LanguageInfoValidationError is the validation error returned by
// LanguageInfo.Validate if the designated constraints aren't met.
type LanguageInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LanguageInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LanguageInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LanguageInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LanguageInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LanguageInfoValidationError) ErrorName() string { return "LanguageInfoValidationError" }

// Error satisfies the builtin error interface
func (e LanguageInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLanguageInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LanguageInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LanguageInfoValidationError{}

// Validate checks the field values on Page with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Page) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Page with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PageMultiError, or nil if none found.
func (m *Page) ValidateAll() error {
	return m.validate(true)
}

func (m *Page) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for Total

	if len(errors) > 0 {
		return PageMultiError(errors)
	}

	return nil
}

// PageMultiError is an error wrapping multiple validation errors returned by
// Page.ValidateAll() if the designated constraints aren't met.
type PageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageMultiError) AllErrors() []error { return m }

// PageValidationError is the validation error returned by Page.Validate if the
// designated constraints aren't met.
type PageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageValidationError) ErrorName() string { return "PageValidationError" }

// Error satisfies the builtin error interface
func (e PageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageValidationError{}

// Validate checks the field values on LanguageRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LanguageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LanguageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LanguageRequestMultiError, or nil if none found.
func (m *LanguageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LanguageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LanguageRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LanguageRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LanguageRequestValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	if len(errors) > 0 {
		return LanguageRequestMultiError(errors)
	}

	return nil
}

// LanguageRequestMultiError is an error wrapping multiple validation errors
// returned by LanguageRequest.ValidateAll() if the designated constraints
// aren't met.
type LanguageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LanguageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LanguageRequestMultiError) AllErrors() []error { return m }

// LanguageRequestValidationError is the validation error returned by
// LanguageRequest.Validate if the designated constraints aren't met.
type LanguageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LanguageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LanguageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LanguageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LanguageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LanguageRequestValidationError) ErrorName() string { return "LanguageRequestValidationError" }

// Error satisfies the builtin error interface
func (e LanguageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLanguageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LanguageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LanguageRequestValidationError{}

// Validate checks the field values on LanguageReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LanguageReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LanguageReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LanguageReplyMultiError, or
// nil if none found.
func (m *LanguageReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LanguageReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LanguageReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LanguageReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LanguageReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return LanguageReplyMultiError(errors)
	}

	return nil
}

// LanguageReplyMultiError is an error wrapping multiple validation errors
// returned by LanguageReply.ValidateAll() if the designated constraints
// aren't met.
type LanguageReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LanguageReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LanguageReplyMultiError) AllErrors() []error { return m }

// LanguageReplyValidationError is the validation error returned by
// LanguageReply.Validate if the designated constraints aren't met.
type LanguageReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LanguageReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LanguageReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LanguageReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LanguageReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LanguageReplyValidationError) ErrorName() string { return "LanguageReplyValidationError" }

// Error satisfies the builtin error interface
func (e LanguageReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLanguageReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LanguageReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LanguageReplyValidationError{}

// Validate checks the field values on RepoReply_Data with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepoReply_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoReply_Data with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepoReply_DataMultiError,
// or nil if none found.
func (m *RepoReply_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoReply_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepoReply_DataValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepoReply_DataValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepoReply_DataValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRepos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RepoReply_DataValidationError{
						field:  fmt.Sprintf("Repos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RepoReply_DataValidationError{
						field:  fmt.Sprintf("Repos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RepoReply_DataValidationError{
					field:  fmt.Sprintf("Repos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RepoReply_DataMultiError(errors)
	}

	return nil
}

// RepoReply_DataMultiError is an error wrapping multiple validation errors
// returned by RepoReply_Data.ValidateAll() if the designated constraints
// aren't met.
type RepoReply_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoReply_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoReply_DataMultiError) AllErrors() []error { return m }

// RepoReply_DataValidationError is the validation error returned by
// RepoReply_Data.Validate if the designated constraints aren't met.
type RepoReply_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoReply_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoReply_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoReply_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoReply_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoReply_DataValidationError) ErrorName() string { return "RepoReply_DataValidationError" }

// Error satisfies the builtin error interface
func (e RepoReply_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoReply_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoReply_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoReply_DataValidationError{}

// Validate checks the field values on OwnerReply_Data with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OwnerReply_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OwnerReply_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OwnerReply_DataMultiError, or nil if none found.
func (m *OwnerReply_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *OwnerReply_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OwnerReply_DataValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OwnerReply_DataValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OwnerReply_DataValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOwners() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OwnerReply_DataValidationError{
						field:  fmt.Sprintf("Owners[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OwnerReply_DataValidationError{
						field:  fmt.Sprintf("Owners[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OwnerReply_DataValidationError{
					field:  fmt.Sprintf("Owners[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OwnerReply_DataMultiError(errors)
	}

	return nil
}

// OwnerReply_DataMultiError is an error wrapping multiple validation errors
// returned by OwnerReply_Data.ValidateAll() if the designated constraints
// aren't met.
type OwnerReply_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OwnerReply_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OwnerReply_DataMultiError) AllErrors() []error { return m }

// OwnerReply_DataValidationError is the validation error returned by
// OwnerReply_Data.Validate if the designated constraints aren't met.
type OwnerReply_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OwnerReply_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OwnerReply_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OwnerReply_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OwnerReply_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OwnerReply_DataValidationError) ErrorName() string { return "OwnerReply_DataValidationError" }

// Error satisfies the builtin error interface
func (e OwnerReply_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOwnerReply_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OwnerReply_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OwnerReply_DataValidationError{}

// Validate checks the field values on LanguageReply_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LanguageReply_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LanguageReply_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LanguageReply_DataMultiError, or nil if none found.
func (m *LanguageReply_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *LanguageReply_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LanguageReply_DataValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LanguageReply_DataValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LanguageReply_DataValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLanguages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LanguageReply_DataValidationError{
						field:  fmt.Sprintf("Languages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LanguageReply_DataValidationError{
						field:  fmt.Sprintf("Languages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LanguageReply_DataValidationError{
					field:  fmt.Sprintf("Languages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LanguageReply_DataMultiError(errors)
	}

	return nil
}

// LanguageReply_DataMultiError is an error wrapping multiple validation errors
// returned by LanguageReply_Data.ValidateAll() if the designated constraints
// aren't met.
type LanguageReply_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LanguageReply_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LanguageReply_DataMultiError) AllErrors() []error { return m }

// LanguageReply_DataValidationError is the validation error returned by
// LanguageReply_Data.Validate if the designated constraints aren't met.
type LanguageReply_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LanguageReply_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LanguageReply_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LanguageReply_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LanguageReply_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LanguageReply_DataValidationError) ErrorName() string {
	return "LanguageReply_DataValidationError"
}

// Error satisfies the builtin error interface
func (e LanguageReply_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLanguageReply_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LanguageReply_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LanguageReply_DataValidationError{}
