// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/open_source/v1/open_source.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on RepoInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepoInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepoInfoMultiError, or nil
// if none found.
func (m *RepoInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for FullName

	// no validation rules for Image

	// no validation rules for OwnerId

	// no validation rules for OwnerName

	// no validation rules for Private

	// no validation rules for Desc

	// no validation rules for HtmlUrl

	// no validation rules for Homepage

	// no validation rules for CloneUrl

	// no validation rules for StargazersCount

	// no validation rules for WatchersCount

	// no validation rules for Language

	// no validation rules for LanguageId

	// no validation rules for ForksCount

	// no validation rules for OpenIssuesCount

	// no validation rules for OpenIssues

	// no validation rules for Watchers

	// no validation rules for DefaultBranch

	// no validation rules for Score

	// no validation rules for Size

	// no validation rules for Forks

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return RepoInfoMultiError(errors)
	}

	return nil
}

// RepoInfoMultiError is an error wrapping multiple validation errors returned
// by RepoInfo.ValidateAll() if the designated constraints aren't met.
type RepoInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoInfoMultiError) AllErrors() []error { return m }

// RepoInfoValidationError is the validation error returned by
// RepoInfo.Validate if the designated constraints aren't met.
type RepoInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoInfoValidationError) ErrorName() string { return "RepoInfoValidationError" }

// Error satisfies the builtin error interface
func (e RepoInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoInfoValidationError{}

// Validate checks the field values on QueryFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryFilterMultiError, or
// nil if none found.
func (m *QueryFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetValue

	// no validation rules for Op

	// no validation rules for Field

	if len(errors) > 0 {
		return QueryFilterMultiError(errors)
	}

	return nil
}

// QueryFilterMultiError is an error wrapping multiple validation errors
// returned by QueryFilter.ValidateAll() if the designated constraints aren't met.
type QueryFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryFilterMultiError) AllErrors() []error { return m }

// QueryFilterValidationError is the validation error returned by
// QueryFilter.Validate if the designated constraints aren't met.
type QueryFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryFilterValidationError) ErrorName() string { return "QueryFilterValidationError" }

// Error satisfies the builtin error interface
func (e QueryFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryFilterValidationError{}

// Validate checks the field values on SortOrder with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SortOrder) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SortOrder with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SortOrderMultiError, or nil
// if none found.
func (m *SortOrder) ValidateAll() error {
	return m.validate(true)
}

func (m *SortOrder) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Order

	// no validation rules for Field

	if len(errors) > 0 {
		return SortOrderMultiError(errors)
	}

	return nil
}

// SortOrderMultiError is an error wrapping multiple validation errors returned
// by SortOrder.ValidateAll() if the designated constraints aren't met.
type SortOrderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SortOrderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SortOrderMultiError) AllErrors() []error { return m }

// SortOrderValidationError is the validation error returned by
// SortOrder.Validate if the designated constraints aren't met.
type SortOrderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SortOrderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SortOrderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SortOrderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SortOrderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SortOrderValidationError) ErrorName() string { return "SortOrderValidationError" }

// Error satisfies the builtin error interface
func (e SortOrderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSortOrder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SortOrderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SortOrderValidationError{}

// Validate checks the field values on RepoRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepoRequestMultiError, or
// nil if none found.
func (m *RepoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for PageSize

	// no validation rules for Name

	// no validation rules for Desc

	// no validation rules for LanguageId

	// no validation rules for OwnerId

	// no validation rules for ID

	for idx, item := range m.GetFilters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RepoRequestValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RepoRequestValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RepoRequestValidationError{
					field:  fmt.Sprintf("Filters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepoRequestValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepoRequestValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepoRequestValidationError{
				field:  "Sort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RepoRequestMultiError(errors)
	}

	return nil
}

// RepoRequestMultiError is an error wrapping multiple validation errors
// returned by RepoRequest.ValidateAll() if the designated constraints aren't met.
type RepoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoRequestMultiError) AllErrors() []error { return m }

// RepoRequestValidationError is the validation error returned by
// RepoRequest.Validate if the designated constraints aren't met.
type RepoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoRequestValidationError) ErrorName() string { return "RepoRequestValidationError" }

// Error satisfies the builtin error interface
func (e RepoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoRequestValidationError{}

// Validate checks the field values on RepoReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepoReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepoReplyMultiError, or nil
// if none found.
func (m *RepoReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for PageSize

	// no validation rules for Total

	for idx, item := range m.GetRepos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RepoReplyValidationError{
						field:  fmt.Sprintf("Repos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RepoReplyValidationError{
						field:  fmt.Sprintf("Repos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RepoReplyValidationError{
					field:  fmt.Sprintf("Repos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RepoReplyMultiError(errors)
	}

	return nil
}

// RepoReplyMultiError is an error wrapping multiple validation errors returned
// by RepoReply.ValidateAll() if the designated constraints aren't met.
type RepoReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoReplyMultiError) AllErrors() []error { return m }

// RepoReplyValidationError is the validation error returned by
// RepoReply.Validate if the designated constraints aren't met.
type RepoReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoReplyValidationError) ErrorName() string { return "RepoReplyValidationError" }

// Error satisfies the builtin error interface
func (e RepoReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoReplyValidationError{}

// Validate checks the field values on RepoByCategoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RepoByCategoryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoByCategoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RepoByCategoryRequestMultiError, or nil if none found.
func (m *RepoByCategoryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoByCategoryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for PageSize

	// no validation rules for ID

	if len(errors) > 0 {
		return RepoByCategoryRequestMultiError(errors)
	}

	return nil
}

// RepoByCategoryRequestMultiError is an error wrapping multiple validation
// errors returned by RepoByCategoryRequest.ValidateAll() if the designated
// constraints aren't met.
type RepoByCategoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoByCategoryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoByCategoryRequestMultiError) AllErrors() []error { return m }

// RepoByCategoryRequestValidationError is the validation error returned by
// RepoByCategoryRequest.Validate if the designated constraints aren't met.
type RepoByCategoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoByCategoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoByCategoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoByCategoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoByCategoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoByCategoryRequestValidationError) ErrorName() string {
	return "RepoByCategoryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RepoByCategoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoByCategoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoByCategoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoByCategoryRequestValidationError{}

// Validate checks the field values on RepoByCategoryReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RepoByCategoryReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoByCategoryReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RepoByCategoryReplyMultiError, or nil if none found.
func (m *RepoByCategoryReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoByCategoryReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for PageSize

	// no validation rules for Total

	for idx, item := range m.GetRepos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RepoByCategoryReplyValidationError{
						field:  fmt.Sprintf("Repos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RepoByCategoryReplyValidationError{
						field:  fmt.Sprintf("Repos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RepoByCategoryReplyValidationError{
					field:  fmt.Sprintf("Repos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RepoByCategoryReplyMultiError(errors)
	}

	return nil
}

// RepoByCategoryReplyMultiError is an error wrapping multiple validation
// errors returned by RepoByCategoryReply.ValidateAll() if the designated
// constraints aren't met.
type RepoByCategoryReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoByCategoryReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoByCategoryReplyMultiError) AllErrors() []error { return m }

// RepoByCategoryReplyValidationError is the validation error returned by
// RepoByCategoryReply.Validate if the designated constraints aren't met.
type RepoByCategoryReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoByCategoryReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoByCategoryReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoByCategoryReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoByCategoryReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoByCategoryReplyValidationError) ErrorName() string {
	return "RepoByCategoryReplyValidationError"
}

// Error satisfies the builtin error interface
func (e RepoByCategoryReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoByCategoryReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoByCategoryReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoByCategoryReplyValidationError{}

// Validate checks the field values on OwnerInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OwnerInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OwnerInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OwnerInfoMultiError, or nil
// if none found.
func (m *OwnerInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *OwnerInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AvatarUrl

	// no validation rules for Type

	// no validation rules for Login

	// no validation rules for HtmlUrl

	// no validation rules for Name

	// no validation rules for Email

	// no validation rules for Bio

	// no validation rules for PublicRepos

	// no validation rules for PublicGists

	// no validation rules for Followers

	// no validation rules for Following

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return OwnerInfoMultiError(errors)
	}

	return nil
}

// OwnerInfoMultiError is an error wrapping multiple validation errors returned
// by OwnerInfo.ValidateAll() if the designated constraints aren't met.
type OwnerInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OwnerInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OwnerInfoMultiError) AllErrors() []error { return m }

// OwnerInfoValidationError is the validation error returned by
// OwnerInfo.Validate if the designated constraints aren't met.
type OwnerInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OwnerInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OwnerInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OwnerInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OwnerInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OwnerInfoValidationError) ErrorName() string { return "OwnerInfoValidationError" }

// Error satisfies the builtin error interface
func (e OwnerInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOwnerInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OwnerInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OwnerInfoValidationError{}

// Validate checks the field values on OwnerRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OwnerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OwnerRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OwnerRequestMultiError, or
// nil if none found.
func (m *OwnerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OwnerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for PageSize

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for Email

	// no validation rules for ID

	if len(errors) > 0 {
		return OwnerRequestMultiError(errors)
	}

	return nil
}

// OwnerRequestMultiError is an error wrapping multiple validation errors
// returned by OwnerRequest.ValidateAll() if the designated constraints aren't met.
type OwnerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OwnerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OwnerRequestMultiError) AllErrors() []error { return m }

// OwnerRequestValidationError is the validation error returned by
// OwnerRequest.Validate if the designated constraints aren't met.
type OwnerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OwnerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OwnerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OwnerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OwnerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OwnerRequestValidationError) ErrorName() string { return "OwnerRequestValidationError" }

// Error satisfies the builtin error interface
func (e OwnerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOwnerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OwnerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OwnerRequestValidationError{}

// Validate checks the field values on OwnerReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OwnerReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OwnerReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OwnerReplyMultiError, or
// nil if none found.
func (m *OwnerReply) ValidateAll() error {
	return m.validate(true)
}

func (m *OwnerReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for PageSize

	// no validation rules for Total

	for idx, item := range m.GetOwners() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OwnerReplyValidationError{
						field:  fmt.Sprintf("Owners[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OwnerReplyValidationError{
						field:  fmt.Sprintf("Owners[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OwnerReplyValidationError{
					field:  fmt.Sprintf("Owners[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OwnerReplyMultiError(errors)
	}

	return nil
}

// OwnerReplyMultiError is an error wrapping multiple validation errors
// returned by OwnerReply.ValidateAll() if the designated constraints aren't met.
type OwnerReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OwnerReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OwnerReplyMultiError) AllErrors() []error { return m }

// OwnerReplyValidationError is the validation error returned by
// OwnerReply.Validate if the designated constraints aren't met.
type OwnerReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OwnerReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OwnerReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OwnerReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OwnerReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OwnerReplyValidationError) ErrorName() string { return "OwnerReplyValidationError" }

// Error satisfies the builtin error interface
func (e OwnerReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOwnerReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OwnerReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OwnerReplyValidationError{}

// Validate checks the field values on LanguageInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LanguageInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LanguageInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LanguageInfoMultiError, or
// nil if none found.
func (m *LanguageInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *LanguageInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for ImageUrl

	// no validation rules for RepoUrl

	// no validation rules for Bio

	if len(errors) > 0 {
		return LanguageInfoMultiError(errors)
	}

	return nil
}

// LanguageInfoMultiError is an error wrapping multiple validation errors
// returned by LanguageInfo.ValidateAll() if the designated constraints aren't met.
type LanguageInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LanguageInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LanguageInfoMultiError) AllErrors() []error { return m }

// LanguageInfoValidationError is the validation error returned by
// LanguageInfo.Validate if the designated constraints aren't met.
type LanguageInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LanguageInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LanguageInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LanguageInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LanguageInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LanguageInfoValidationError) ErrorName() string { return "LanguageInfoValidationError" }

// Error satisfies the builtin error interface
func (e LanguageInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLanguageInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LanguageInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LanguageInfoValidationError{}

// Validate checks the field values on LanguageRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LanguageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LanguageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LanguageRequestMultiError, or nil if none found.
func (m *LanguageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LanguageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for PageSize

	// no validation rules for ID

	// no validation rules for Name

	if len(errors) > 0 {
		return LanguageRequestMultiError(errors)
	}

	return nil
}

// LanguageRequestMultiError is an error wrapping multiple validation errors
// returned by LanguageRequest.ValidateAll() if the designated constraints
// aren't met.
type LanguageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LanguageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LanguageRequestMultiError) AllErrors() []error { return m }

// LanguageRequestValidationError is the validation error returned by
// LanguageRequest.Validate if the designated constraints aren't met.
type LanguageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LanguageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LanguageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LanguageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LanguageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LanguageRequestValidationError) ErrorName() string { return "LanguageRequestValidationError" }

// Error satisfies the builtin error interface
func (e LanguageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLanguageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LanguageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LanguageRequestValidationError{}

// Validate checks the field values on LanguageReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LanguageReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LanguageReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LanguageReplyMultiError, or
// nil if none found.
func (m *LanguageReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LanguageReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for PageSize

	// no validation rules for Total

	for idx, item := range m.GetLanguages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LanguageReplyValidationError{
						field:  fmt.Sprintf("Languages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LanguageReplyValidationError{
						field:  fmt.Sprintf("Languages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LanguageReplyValidationError{
					field:  fmt.Sprintf("Languages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LanguageReplyMultiError(errors)
	}

	return nil
}

// LanguageReplyMultiError is an error wrapping multiple validation errors
// returned by LanguageReply.ValidateAll() if the designated constraints
// aren't met.
type LanguageReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LanguageReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LanguageReplyMultiError) AllErrors() []error { return m }

// LanguageReplyValidationError is the validation error returned by
// LanguageReply.Validate if the designated constraints aren't met.
type LanguageReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LanguageReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LanguageReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LanguageReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LanguageReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LanguageReplyValidationError) ErrorName() string { return "LanguageReplyValidationError" }

// Error satisfies the builtin error interface
func (e LanguageReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLanguageReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LanguageReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LanguageReplyValidationError{}

// Validate checks the field values on CommonReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommonReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommonReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommonReplyMultiError, or
// nil if none found.
func (m *CommonReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CommonReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommonReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommonReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommonReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommonReplyMultiError(errors)
	}

	return nil
}

// CommonReplyMultiError is an error wrapping multiple validation errors
// returned by CommonReply.ValidateAll() if the designated constraints aren't met.
type CommonReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommonReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommonReplyMultiError) AllErrors() []error { return m }

// CommonReplyValidationError is the validation error returned by
// CommonReply.Validate if the designated constraints aren't met.
type CommonReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommonReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommonReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommonReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommonReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommonReplyValidationError) ErrorName() string { return "CommonReplyValidationError" }

// Error satisfies the builtin error interface
func (e CommonReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommonReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommonReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommonReplyValidationError{}

// Validate checks the field values on RepoCategoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RepoCategoryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoCategoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RepoCategoryRequestMultiError, or nil if none found.
func (m *RepoCategoryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoCategoryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for PageSize

	// no validation rules for Name

	// no validation rules for ID

	if len(errors) > 0 {
		return RepoCategoryRequestMultiError(errors)
	}

	return nil
}

// RepoCategoryRequestMultiError is an error wrapping multiple validation
// errors returned by RepoCategoryRequest.ValidateAll() if the designated
// constraints aren't met.
type RepoCategoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoCategoryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoCategoryRequestMultiError) AllErrors() []error { return m }

// RepoCategoryRequestValidationError is the validation error returned by
// RepoCategoryRequest.Validate if the designated constraints aren't met.
type RepoCategoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoCategoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoCategoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoCategoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoCategoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoCategoryRequestValidationError) ErrorName() string {
	return "RepoCategoryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RepoCategoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoCategoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoCategoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoCategoryRequestValidationError{}

// Validate checks the field values on RepoCategoryInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RepoCategoryInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoCategoryInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RepoCategoryInfoMultiError, or nil if none found.
func (m *RepoCategoryInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoCategoryInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for ImageUrl

	if len(errors) > 0 {
		return RepoCategoryInfoMultiError(errors)
	}

	return nil
}

// RepoCategoryInfoMultiError is an error wrapping multiple validation errors
// returned by RepoCategoryInfo.ValidateAll() if the designated constraints
// aren't met.
type RepoCategoryInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoCategoryInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoCategoryInfoMultiError) AllErrors() []error { return m }

// RepoCategoryInfoValidationError is the validation error returned by
// RepoCategoryInfo.Validate if the designated constraints aren't met.
type RepoCategoryInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoCategoryInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoCategoryInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoCategoryInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoCategoryInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoCategoryInfoValidationError) ErrorName() string { return "RepoCategoryInfoValidationError" }

// Error satisfies the builtin error interface
func (e RepoCategoryInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoCategoryInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoCategoryInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoCategoryInfoValidationError{}

// Validate checks the field values on RepoCategoryReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RepoCategoryReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoCategoryReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RepoCategoryReplyMultiError, or nil if none found.
func (m *RepoCategoryReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoCategoryReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for PageSize

	// no validation rules for Total

	for idx, item := range m.GetCategory() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RepoCategoryReplyValidationError{
						field:  fmt.Sprintf("Category[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RepoCategoryReplyValidationError{
						field:  fmt.Sprintf("Category[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RepoCategoryReplyValidationError{
					field:  fmt.Sprintf("Category[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RepoCategoryReplyMultiError(errors)
	}

	return nil
}

// RepoCategoryReplyMultiError is an error wrapping multiple validation errors
// returned by RepoCategoryReply.ValidateAll() if the designated constraints
// aren't met.
type RepoCategoryReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoCategoryReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoCategoryReplyMultiError) AllErrors() []error { return m }

// RepoCategoryReplyValidationError is the validation error returned by
// RepoCategoryReply.Validate if the designated constraints aren't met.
type RepoCategoryReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoCategoryReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoCategoryReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoCategoryReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoCategoryReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoCategoryReplyValidationError) ErrorName() string {
	return "RepoCategoryReplyValidationError"
}

// Error satisfies the builtin error interface
func (e RepoCategoryReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoCategoryReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoCategoryReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoCategoryReplyValidationError{}
